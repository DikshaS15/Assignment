-- ** Normalisation & CTE **

use mavenmovies;

--  First Normal Form :

-- Q1. Identify a table in the sakila database that violates 1NF. Explain how you would normalize it to achieve 1NF.

# Explanation:
/* A table is in 1NF if it contains only atomic (indivisible) values; no repeating groups or arrays are allowed.
Example: Check for any table with columns that contain multiple values in a single cell, such as a list of actors in a single column.
Normalization: Split the multi-valued attributes into separate rows, creating a new table if necessary.*/


 -- Second Normal Form (2NF):

 -- Q2. Choose a table in Sakila and describe how you would determine whether it is in 2NF.If it violates 2NF, explain the steps to normalize it.
 
 # Explanation:
/* A table is in 2NF if it is in 1NF and all non-key attributes are fully functionally dependent on the primary key.
Example: Look for tables where non-primary key columns are dependent on a part of a composite primary key.
Normalization: Move the partially dependent columns to a new table that uses the part of the composite key they depend on as a primary key.*/


-- Third Normal Form (3NF):

  -- Q3. Identify a table in Sakila that violates 3NF. Describe the transitive dependencies present and outline the steps to normalize the table to 3NF.
  
  # Explanation:
/* A table is in 3NF if it is in 2NF and all its attributes are not only dependent on the primary key but are also non-transitively dependent.
Example: Identify any table where a non-key column depends on another non-key column.
Normalization: Move the dependent columns to a new table where the column they depend on becomes a key.*/


 -- Normalization Process:

 -- Q4. Take a specific table in Sakila and guide through the process of normalizing it from the initial unnormalized form up to at least 2NF.
 
 # Explanation:
/* Start with the raw table (possibly with repeating groups or multi-valued attributes).
Break it down to 1NF by removing repeating groups.
Achieve 2NF by eliminating partial dependencies.*/


-- 5. CTE Basics:

--  a. Write a query using a CTE to retrieve the distinct list of actor names and the number of films they 

--  have acted in from the actor and film_actor tables.
 
WITH FilmLanguageCTE AS (
    SELECT 
        f.title AS film_title, 
        l.name AS language_name, 
        f.rental_rate
    FROM 
        film f
    JOIN 
        language l ON f.language_id = l.language_id
)
SELECT * 
FROM FilmLanguageCTE;


-- 6. CTE with Joins:

--  a. Create a CTE that combines information from the film and language tables to display the film title, 

--  language name, and rental rate.

WITH CustomerRevenue AS (
    SELECT 
        c.customer_id, 
        c.first_name, 
        c.last_name, 
        SUM(p.amount) AS total_revenue
    FROM 
        customer c
    JOIN 
        payment p ON c.customer_id = p.customer_id
    GROUP BY 
        c.customer_id, c.first_name, c.last_name
)
SELECT * 
FROM CustomerRevenue;


 -- 7 CTE for Aggregation:
 --  a. Write a query using a CTE to find the total revenue generated by each customer (sum of payments) 
--  from the customer and payment tables.

with Total_revenue as (

select concat(c.first_name + " " + c.last_name) as Name_ , sum(p.amount) as Total_revenue 
from customer c join payment p
on c.customer_id = p.customer_id 
 group by Name_)
 
 select * from Total_revenue;
 
 
 -- 8 CTE with Window Functions:

--  a. Utilize a CTE with a window function to rank films based on their rental duration from the film table.

WITH FilmRankingCTE AS (
    SELECT 
        film_id, 
        title AS film_title, 
        rental_duration, 
        RANK() OVER (ORDER BY rental_duration DESC) AS rank_
    FROM 
        film
)
SELECT * 
FROM FilmRankingCTE
ORDER BY rank_, film_title;


 -- 9 CTE and Filtering:

--  a. Create a CTE to list customers who have made more than two rentals, and then join this CTE with the 

--  customer table to retrieve additional customer details

WITH CustomerRentalCount AS (
    SELECT 
        r.customer_id, 
        COUNT(r.rental_id) AS rental_count
    FROM 
        rental r
    GROUP BY 
        r.customer_id
    HAVING 
        COUNT(r.rental_id) > 2
)
SELECT 
    c.customer_id, 
    c.first_name, 
    c.last_name, 
    c.email, 
    crc.rental_count
FROM 
    CustomerRentalCount crc
JOIN 
    customer c ON crc.customer_id = c.customer_id
ORDER BY 
    crc.rental_count DESC, c.last_name, c.first_name;
    
    
    -- 10 CTE for Date Calculations:

--  a. Write a query using a CTE to find the total number of rentals made each month, considering the 

--  rental_date from the rental table

WITH MonthlyRentalCount AS (
    SELECT 
        DATE_FORMAT(rental_date, '%Y-%m') AS rental_month,
        COUNT(rental_id) AS total_rentals
    FROM 
        rental
    GROUP BY 
        DATE_FORMAT(rental_date, '%Y-%m')
    ORDER BY 
        rental_month
)
SELECT * 
FROM MonthlyRentalCount;


-- 11' CTE and Self-Join:

--  a. Create a CTE to generate a report showing pairs of actors who have appeared in the same film 

--  together, using the film_actor table.

WITH ActorPairs AS (
    SELECT 
        fa1.actor_id AS actor1_id,
        fa2.actor_id AS actor2_id,
        f.title AS film_title
    FROM 
        film_actor fa1
    JOIN 
        film_actor fa2 ON fa1.film_id = fa2.film_id AND fa1.actor_id < fa2.actor_id
    JOIN 
        film f ON fa1.film_id = f.film_id
)
SELECT 
    a1.actor_id AS actor1_id, 
    a1.first_name AS actor1_first_name, 
    a1.last_name AS actor1_last_name, 
    a2.actor_id AS actor2_id, 
    a2.first_name AS actor2_first_name, 
    a2.last_name AS actor2_last_name, 
    film_title
FROM 
    ActorPairs ap
JOIN 
    actor a1 ON ap.actor1_id = a1.actor_id
JOIN 
    actor a2 ON ap.actor2_id = a2.actor_id
ORDER BY 
    film_title, actor1_last_name, actor2_last_name;
    
    
-- 12. CTE for Recursive Search:

--  a. Implement a recursive CTE to find all employees in the staff table who report to a specific manager, 

--  considering the reports_to column

select * from staff;

			